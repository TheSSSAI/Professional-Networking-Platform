"test_id","feature_area","test_type","test_level","priority","automation_candidate","automation_roi","test_description","business_risk","technical_complexity","preconditions","test_steps","expected_result","test_data_needs","tools_required","estimated_effort_hours","automation_effort_hours","maintenance_effort_annual","dependencies","environment_requirements","success_criteria","failure_impact","regression_frequency","data_setup_complexity","cleanup_requirements","security_considerations","performance_expectations","accessibility_requirements"
"TEST-IAM-001","User Registration","Functional","End-to-End","Critical","true","High","Verify the complete user registration flow, from form submission to account activation via email link, ensuring the account status transitions correctly from 'inactive' to 'active'.","High - Failure blocks all user acquisition.","High","Identity Service is running with a connection to PostgreSQL. A mock email service (MailHog) is running.","1. Send a POST request to /auth/register with valid, unique email and complex password. 2. Verify a 201 Created response. 3. Check the database to confirm user exists with 'inactive' status and a verification token is stored. 4. Fetch the verification link from the mock email service. 5. Send a GET request to the verification URL. 6. Verify the user is redirected to the login page with a success message. 7. Check the database to confirm user status is now 'active' and the token is invalidated.","User account is created as 'inactive' and successfully transitioned to 'active' after email verification. The verification token is single-use.","Unique email address; Password meeting complexity rules; Access to mock email service.","Jest, Supertest, Testcontainers (for DB), MailHog","8","16","4","PostgreSQL, AWS SES (mocked), Event Bus","Integration environment with full service stack","100% test pass rate; User status updated correctly; Email content is correct.","Critical - Users cannot onboard.","Every commit to main branch","Low","Delete created user and tokens after test.","Verification token must be unique, unguessable, and single-use.","Registration API response < 200ms P95.","N/A (API Test)"
"TEST-IAM-002","User Login & Session Management","Security","Integration","Critical","true","High","Verify that a user can log in with valid credentials, receive a JWT access token and an HttpOnly refresh token cookie, and use the access token to access a protected endpoint.","Critical - Failure prevents all authenticated users from accessing the platform.","Medium","A registered and 'active' user exists in the database.","1. Send POST to /auth/login with correct credentials. 2. Verify 200 OK response, presence of `accessToken` in body, and `Set-Cookie` header with HttpOnly refresh token. 3. Create a test protected endpoint (e.g., /auth/profile). 4. Send GET to /auth/profile with the `accessToken` in the Authorization header. 5. Verify 200 OK response with user data.","User is successfully authenticated, receives valid tokens, and can use the access token for authorized requests.","Active user credentials.","Jest, Supertest, Testcontainers","6","12","3","PostgreSQL, JWT library, Passport.js","Integration environment","Login successful; Tokens are valid and correctly placed (body/cookie); Protected endpoint access is granted.","Critical - All users are locked out.","Every commit to main branch","Medium - Requires user in 'active' state.","N/A","Refresh token must be HttpOnly and secure. Access token must be short-lived.","Login API response < 200ms P95.","N/A (API Test)"
"TEST-IAM-003","User Logout & Token Invalidation","Security","End-to-End","Critical","true","High","Verify that after logging out, the user's access token is added to a Redis blocklist and cannot be reused to access protected endpoints.","High - Failure allows session hijacking via stolen tokens.","High","An active, logged-in user session.","1. Log in as a user to get a valid access token. 2. Send POST to /auth/logout with the access token. 3. Verify 200 OK response and that the refresh token cookie is cleared. 4. Check Redis to confirm the token's JTI has been added to the blocklist. 5. Send GET to a protected endpoint using the same (now logged-out) access token. 6. Verify the request is rejected with a 401 Unauthorized status.","The access token is invalidated on the server-side upon logout and can no longer be used for authentication.","Active user credentials.","Jest, Supertest, Testcontainers (DB and Redis)","8","16","4","PostgreSQL, Redis","Integration environment with DB and Redis","Logout successful; Token JTI in Redis blocklist; Subsequent request with old token fails with 401.","Critical - Major session security vulnerability.","Every commit to main branch","Medium","Flush Redis after test.","Blocklist check must be performed on every authenticated request.","Logout API < 100ms P95. Blocklist check should add <5ms to requests.","N/A (API Test)"
"TEST-IAM-004","Password Recovery","Functional","End-to-End","Critical","true","High","Verify the full password reset flow, including requesting a reset, using the time-limited link, setting a new password, and confirming old sessions are invalidated.","High - Failure locks users out of their accounts permanently.","High","An active user exists. Mock email service is running.","1. Log in to get an initial access token. 2. Send POST to /auth/forgot-password with user's email. 3. Verify generic success response and fetch reset link from mock email. 4. Send POST to /auth/reset-password with the token and a new complex password. 5. Verify success response. 6. Attempt to use the initial access token from step 1 on a protected endpoint; verify it fails with 401. 7. Log in with the new password; verify it succeeds.","User can reset password, the reset token is single-use and time-limited, and all old sessions are invalidated upon reset.","Active user credentials.","Jest, Supertest, Testcontainers, MailHog, Time-mocking library","10","20","5","PostgreSQL, Redis, AWS SES (mocked)","Integration environment","Password reset succeeds; Old sessions are invalidated; User can log in with new password.","Critical - Users cannot recover accounts.","Every commit to main branch","Medium","Delete user after test.","Reset token must be secure and time-limited. Session invalidation is critical.","API responses < 500ms P95.","N/A (API Test)"
"TEST-IAM-005","Multi-Factor Authentication (MFA)","Security","Integration","High","true","High","Verify the complete MFA lifecycle: setup, verification, login with MFA, and disablement.","High - Flaw in MFA logic undermines a key security feature.","High","An active user exists.","1. (Setup) POST to /auth/mfa/setup to get a secret. 2. (Verify) Use a TOTP library to generate a code and POST to /auth/mfa/verify. 3. (Login) POST to /auth/login, receive MFA challenge. 4. POST to /auth/mfa/login with a valid TOTP code. 5. Verify login succeeds and tokens are issued. 6. (Disable) POST to /auth/mfa/disable with password and TOTP. 7. Verify MFA is disabled.","User can enable MFA, log in using a second factor, and securely disable it.","Active user credentials.","Jest, Supertest, Testcontainers, TOTP library (e.g., otplib)","12","24","6","PostgreSQL","Integration environment","MFA can be enabled, is enforced at login, and can be disabled. Incorrect codes are rejected.","High - Compromises enhanced account security.","Every release","Medium","Reset user's MFA status after test.","MFA secrets must be stored encrypted. Rate limiting on MFA endpoints is essential.","MFA validation < 150ms P95.","N/A (API Test)"
"TEST-IAM-006","Account Deletion","Compliance","End-to-End","Critical","true","High","Verify the account deletion lifecycle: request with re-authentication, cancellation by logging in, and final data purge by the scheduled job after the grace period.","Critical - Failure leads to non-compliance with GDPR/CCPA and data privacy breaches.","High","An active user exists. A mock SQS/SNS bus is available.","1. (Request) POST to /users/me/delete with the user's password. 2. Verify user is logged out and status is 'pending_deletion'. 3. (Cancel) Log in again. 4. Verify status is reverted to 'active'. 5. (Purge) Re-request deletion. Use time-mocking to advance time past grace period. 6. Trigger the purge job manually. 7. Verify the user record is deleted, an audit log entry is created, and a `PurgeUserData` event is emitted.","User can request deletion, cancel it within the grace period, and data is verifiably purged after the grace period, with a full audit trail.","Active user credentials.","Jest, Supertest, Testcontainers, Time-mocking library, Mock AWS SQS/SNS","12","24","8","PostgreSQL, Event Bus, Scheduled Jobs","Integration environment","Deletion flow is compliant; data is purged; audit log is created; cancellation works.","Critical - Legal and financial penalties for non-compliance.","Every release","High","Full database cleanup required.","Purge process must be atomic and complete across all systems.","Purge job must not impact live system performance.","N/A (API Test)"