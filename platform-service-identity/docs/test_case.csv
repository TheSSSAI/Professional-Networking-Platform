"test_id","feature_area","test_type","test_level","priority","automation_candidate","automation_roi","test_description","business_risk","technical_complexity","preconditions","test_steps","expected_result","test_data_needs","tools_required","estimated_effort_hours","automation_effort_hours","maintenance_effort_annual","dependencies","environment_requirements","success_criteria","failure_impact","regression_frequency","data_setup_complexity","cleanup_requirements","security_considerations","performance_expectations","accessibility_requirements"
"TEST-GW-AUTH-001","Authentication & Authorization","Security","Integration","Critical","true","High","Verify the JWT Authorizer correctly rejects requests with a token whose JTI is on the Redis blocklist.","High - Failure allows session hijacking after logout.","Medium","A valid JWT is generated for a user. The user logs out, adding the token's JTI to the Redis blocklist. A protected GraphQL endpoint exists.","1. Log in as a test user to obtain a valid JWT. 2. Call the logout endpoint to blocklist the token. 3. Attempt to call a protected GraphQL query (e.g., `userProfile`) using the blocklisted token. 4. Verify the response.","The API Gateway returns a 401 Unauthorized status code and the request does not reach the GraphQL resolver.","Test user account credentials; Redis instance for blocklisting.","Jest; Supertest; Redis Client; Postman","6","12","4","US-GW-002, US-GW-004","Integration environment with live Auth Service and Redis.","100% rejection rate for blocklisted tokens.","Critical - Compromises the entire session management security model.","Every commit to the authorizer.","Medium","Clear blocklisted tokens from Redis after test run.","This is a primary security test case for preventing token reuse attacks.","Rejection response time < 50ms.","N/A"
"TEST-GW-PERF-001","Performance & Scalability","Performance","System","High","true","High","Validate the API Gateway's P95 latency remains under 200ms and demonstrate the effectiveness of the DataLoader pattern in preventing N+1 queries.","High - Poor performance leads to user dissatisfaction and churn.","High","The `userProfile` query and nested resolvers are deployed. A 'perf' environment is available. Test data includes posts with unique authors.","1. Set up a load test script to query a list of 20 posts and their nested authors. 2. Ramp up to 100 concurrent users. 3. Sustain load for 10 minutes. 4. Monitor API Gateway P95 latency via CloudWatch/Grafana. 5. Monitor X-Ray traces to confirm gRPC calls to the Profile service are batched (e.g., 1 call, not 20).","P95 latency remains below 200ms. X-Ray traces confirm a single batched call to the downstream service for the 'author' field, mitigating the N+1 problem.","A large dataset of users and posts to ensure meaningful results.","k6; Grafana; AWS CloudWatch; AWS X-Ray","16","24","8","US-GW-006, US-GW-008","Isolated performance testing environment with production-like specs.","P95 latency < 200ms; Downstream gRPC calls for nested entities are batched into a single call per request.","Critical - Indicates a major performance bottleneck that will fail under production load.","On every release and on-demand for performance-related changes.","High","N/A","Test should run in an isolated environment to not impact production.","Meets the defined NFR (REQ-1-051).","N/A"
"TEST-GW-WS-001","Real-time Communication","Functional","E2E","Critical","true","High","Verify the end-to-end lifecycle of a WebSocket connection: authentication, connection, message sending, and disconnection.","High - Failure blocks all real-time features like chat and notifications.","High","The WebSocket API is deployed to the staging environment. A test user account exists.","1. Obtain a valid JWT for a test user. 2. Establish a WebSocket connection to the WSS endpoint, passing the JWT. 3. Verify the `$connect` handler authenticates and stores the connection ID in DynamoDB. 4. Send a test message. 5. Verify the message handler Lambda receives it and can send a reply. 6. Close the connection. 7. Verify the `$disconnect` handler removes the connection ID from DynamoDB.","The client successfully connects, exchanges messages, and disconnects, with the connection state correctly managed in DynamoDB.","Authenticated test user.","Cypress/Playwright with WebSocket client library; AWS CLI for DynamoDB verification.","12","20","10","US-GW-009","Staging environment with all services deployed.","100% success rate for connection, message exchange, and disconnection.","Critical - All real-time functionality is broken.","Every release.","Low","Ensure no stale connection IDs are left in DynamoDB.","Test must validate that unauthenticated connection attempts are rejected.","Connection established in <1s; Message round-trip <500ms.","N/A"
"TEST-GW-CICD-001","Developer Operations","Process","System","Critical","true","High","Verify the CI pipeline's quality gates (lint, test, coverage, security) correctly block a non-compliant pull request.","Medium - A faulty CI pipeline allows low-quality or vulnerable code into the main branch.","Medium","The GitHub Actions CI workflow is fully configured.","1. Create a new branch. 2. Introduce a linting error, a failing unit test, code that lowers coverage below 80%, AND a dependency with a known high-severity vulnerability. 3. Create a pull request. 4. Observe the CI pipeline execution.","The CI pipeline must fail at each of the corresponding quality gate steps, and the PR must be blocked from merging.","A sample of code with intentional defects.","GitHub Actions; Jest; Codecov; Snyk/CodeQL","4","4","1","US-GW-007, US-GW-011","GitHub repository with configured Actions.","The pipeline fails and blocks the merge.","High - Indicates a failure in automated quality assurance, increasing risk of production defects.","Continuously (on every PR).","Low","Close the intentionally failing PR.","Ensures DevSecOps practices are enforced.","Pipeline should fail quickly, within 5-10 minutes.","N/A"