"test_id","feature_area","test_type","test_level","priority","automation_candidate","automation_roi","test_description","business_risk","technical_complexity","preconditions","test_steps","expected_result","test_data_needs","tools_required","estimated_effort_hours","automation_effort_hours","maintenance_effort_annual","dependencies","environment_requirements","success_criteria","failure_impact","regression_frequency","data_setup_complexity","cleanup_requirements","security_considerations","performance_expectations","accessibility_requirements"
"TEST-IAM-001","User Authentication","Functional","E2E","Critical","true","High","Verify the complete user registration and email verification flow. A user should be able to register, receive an email, click the verification link, and have their account status updated to 'active'.","High - Failure blocks all new user acquisition.","High","User account does not exist. AWS SES integration is configured. A mail-trapping service is active in the test environment.","1. Send 'register' GraphQL mutation with valid, unique credentials. 2. Verify a 200 OK response. 3. Check the database to confirm user exists with 'inactive' status and a verification token. 4. Check the mail-trapping service for the verification email. 5. Extract the verification token from the email. 6. Send 'verifyEmail' mutation with the token. 7. Verify user status in the database is now 'active'.","User account is created as 'inactive' and successfully transitions to 'active' after email verification. The verification token is invalidated after use.","Unique email address; Password meeting complexity rules.","Jest (with Supertest); MailHog/Mailtrap; PostgreSQL Client","6","12","4","Database, AWS SES","Integration environment with mail-trapping.","100% test pass rate; user status updated correctly.","Critical - Users cannot onboard.","Every release","Low","Delete created user account after test run.","Verification token must be secure and single-use.","N/A","N/A (Backend only)"
"TEST-IAM-002","Session Management","Security","Integration","Critical","true","High","Verify that after a user logs out, their access token is successfully blocklisted in Redis and cannot be used to access protected resources.","Critical - Failure allows session hijacking and unauthorized access to user data (RISK-001).","Medium","A verified user account exists. Redis is accessible.","1. Send 'login' mutation to get access and refresh tokens. 2. Store the access token. 3. Send 'logout' mutation. 4. Verify the access token's JTI is present in the Redis blocklist. 5. Send a request to a protected GraphQL query (e.g., 'getMe') using the stored access token. 6. Assert that the response is a 401 Unauthorized error.","The API must reject the request made with the blocklisted token, returning a 401 Unauthorized status.","A verified user account.","Jest (with Supertest); Redis Client","4","8","2","Database, Redis","Integration environment.","API returns 401 Unauthorized for the final step.","Critical - Major security vulnerability.","Every commit to auth code","Medium","Clear user session data and Redis keys.","Test must confirm server-side invalidation is effective.","Blocklist check should add <5ms to request latency.","N/A (Backend only)"
"TEST-IAM-003","Account Recovery","Security","Integration","Critical","true","High","Verify that after a successful password reset, all other active sessions are invalidated.","Critical - If old sessions are not terminated, a compromised machine remains logged in even after a password reset (RISK-001).","High","A verified user account exists.","1. Login as user to get an initial access token ('token_A'). 2. Initiate the password reset flow to get a valid reset token. 3. Use the reset token to set a new password via the 'resetPassword' mutation. 4. Verify the password hash is updated in the database. 5. Attempt to use 'token_A' to access a protected endpoint. 6. Assert that the request is rejected with a 401 Unauthorized error.","The original access token 'token_A' must be invalid after the password has been reset.","A verified user account.","Jest (with Supertest); Redis Client; PostgreSQL Client","5","10","3","Database, Redis","Integration environment.","API returns 401 Unauthorized for the final step.","Critical - Major security vulnerability.","Every release","Medium","Delete user or reset password to known state.","Confirms a key security control is working as intended.","N/A","N/A (Backend only)"
"TEST-IAM-004","User Authentication","Performance","System","High","true","High","Measure the P95 latency of the 'login' mutation under a sustained load of 100 concurrent users.","Medium - Slow login times lead to user frustration and abandonment (RISK-004).","Medium","A deployed instance of the service in a production-like performance environment. A dataset of test users is available.","1. Configure k6 script to read user credentials from a CSV file. 2. Define a scenario with a ramp-up to 100 virtual users over 1 minute. 3. Maintain the 100 VUs load for 5 minutes. 4. Ramp down. 5. The k6 script sends the 'login' GraphQL mutation in a loop.","The 95th percentile of the GraphQL request duration must be less than 200ms.","CSV file with at least 1,000 unique user credentials.","k6; Grafana (for visualization)","8","16","8","Performance test environment","Dedicated, production-scaled performance environment.","P95 latency < 200ms; Error rate < 0.1%.","High - Indicates potential scalability bottlenecks.","Every major release, or on changes to auth code.","High","N/A","Test data must not use real user credentials.","P95 latency < 200ms","N/A (Backend only)"
"TEST-IAM-005","Account Deletion","Functional","E2E","Critical","true","Medium","Verify the end-to-end permanent account deletion flow, including the grace period and final data purge.","High - Failure to correctly purge data leads to GDPR/CCPA compliance violations (RISK-003).","High","A fully provisioned user account. Test environment with an accelerated time configuration for the grace period (e.g., 2 minutes instead of 14 days).","1. Login as the user. 2. Send 'requestAccountDeletion' mutation with correct password. 3. Verify user is logged out. 4. Wait for the accelerated grace period to expire. 5. Verify the Kubernetes CronJob for data purge is triggered. 6. Verify the consumer deletes the user record from the PostgreSQL database. 7. Verify an entry is made in the immutable deletion audit log.","The user's data is permanently removed from the primary database after the grace period, and the action is logged.","A fully provisioned test user.","Jest (with Supertest); PostgreSQL Client; Kubernetes CLI","10","24","12","Database, Kubernetes CronJob, Event Bus","Integration environment with time manipulation capability.","User record is confirmed to be deleted; audit log entry is created.","Critical - Compliance failure and data privacy breach.","Every major release","Medium","N/A (data is deleted as part of the test).","Test must validate that data is irrecoverably deleted.","N/A","N/A (Backend only)"